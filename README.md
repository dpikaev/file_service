# Сервис для загрузки файлов с SFTP

## P.S. Описание моделей - на скрине.
<img width="2293" height="831" alt="2" src="https://github.com/user-attachments/assets/6d66fe1a-c18e-4008-a355-1f9d5048014f" />

## Структура проекта
P.S Абстрактно, для примера, как я бы реализовал сервис
1. models - модели для БД.
2. repositories - я бы использовал репозитории, тут бы находился базовый репозиторий и репозитории для остальных моделей.
3. services - тут был бы сервис для работы с SFTP клиентом, можно сделать интерфейс и сервис с функциями для подключения к SFTP-серверу, получения списка файлов, а также загрузки файлов, плюс сервис для загрузки в minio. Можно еще сделать FileService и ServerService.
4. tasks - тут были бы Celery-таски для проверки новых файлов, загрузки файла с SFTP и отгрузки в MinIO + задача для уведомления внешнего сервиса.
5. notifier - модуль,в котором все, что косается отправки уведомлений в RabbitMq по AMQP
6. routers - тут были бы эндпоинты с CRUD по серверам и списком файлов
7. schemas - тут были бы pydantic схемы


## Логика работы
1. Добавляем новый SFTP-сервер в БД
2. Celery beat периодически, условно, раз в минуту запускает задачу, в которой мы подключаемся к SFTP-серверу, получаем список файлов, после чего для каждого файла проверяем, есть ли он у нас в базе, можно проверять файлы по server_id + filename. Если файла нет - создаем запись в бд в статусе pending. После чего отправляем задачу на загрузку файла в RabbitMQ.
3. Воркер celery берет задачу на загруку файла, меняет статус в бд на downloading. Подключается к SFTP и потоками качает файл, параллельно загружая в MinIO, после загрузки обновляет статус файла в БД на uploaded и сохраняет minio_url. Отправляем задачу для уведомления внешнего сервиса в RabbitMQ. Воркер берет данные файла, формирует JSON и отправляет его в очередь, которую слушает внешний сервис и меняет статус файла в БД на notified.

## Возможные негативные кейсы
1. Файл может быть не донца загружен на SFTP, несколько раз можно проверять размер с паузой, чтобы не пытаться утянуть файлы, которые не до конца загружены.
2. Потеря соедения с SFTP, в таком случае нужны ретраи.
3. Файлы большого размера качаем только стримами, не держим в памяти.
4. Дубликаты файлов, проверяем перед загрузкой.
5. Пустые файлы, если нужны все равно - качаем, если нет, проверяем размер.
6. Отвалился Rabbit или MinIO, повторяем отправку позже.

P.S. Обошелся без Reids, так как кролика хватит, но можно прикрутить для оптимизации, например, кэшировать список файлов, чтобы не ходить в базу за файлами при проверке на существование файла + можно использовать его для блокировки загрузки одного файла двумя воркерами.
